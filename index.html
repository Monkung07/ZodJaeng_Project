<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Locked Screen Party Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    
    <style>
        /* --- ‡∏ä‡∏∏‡∏î‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iPad/iPhone ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞ --- */
        html, body {
            background-color: #0f5132;
            background-image: radial-gradient(circle at center, #146c43 0%, #0a3622 100%);
            overflow: hidden; /* ‡∏´‡πâ‡∏≤‡∏° Scroll */
            user-select: none; /* ‡∏´‡πâ‡∏≤‡∏°‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏≥ */
            font-family: 'Sarabun', sans-serif;
            
            /* Key Fix: ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ã‡∏π‡∏°‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å‡∏ä‡∏ô‡∏¥‡∏î */
            touch-action: none; 
            -ms-touch-action: none;
            overscroll-behavior: none; /* ‡∏õ‡∏¥‡∏î‡πÄ‡∏î‡πâ‡∏á‡∏î‡∏∂‡πã‡∏á */
            -webkit-touch-callout: none; /* ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ñ‡πâ‡∏≤‡∏á */
            height: 100vh;
            width: 100vw;
            position: fixed; /* ‡∏•‡πá‡∏≠‡∏Ñ‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà */
        }

        .scene {
            perspective: 1200px;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 40px;
        }

        .deck-container {
            position: relative;
            width: 220px;
            height: 330px;
        }

        .card {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 1rem;
            transform-style: preserve-3d;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏ï‡∏∞‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô‡∏ö‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î */
            -webkit-tap-highlight-color: transparent;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 1rem;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .card-back {
            background-color: #b91c1c;
            background-image: repeating-linear-gradient(45deg, #991b1b 25%, transparent 25%, transparent 75%, #991b1b 75%, #991b1b), repeating-linear-gradient(45deg, #991b1b 25%, #b91c1c 25%, #b91c1c 75%, #991b1b 75%, #991b1b);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
            border: 6px solid white;
        }
        
        .card-back::after { content: "‚ô†"; font-size: 4rem; color: white; opacity: 0.2; }

        .card-front {
            background: white;
            transform: rotateY(180deg);
            color: #1a1a1a;
            font-size: 1.5rem;
            font-weight: bold;
            border: 2px solid #e5e7eb;
        }

        .card.active {
            z-index: 3000 !important;
            transform: translate(0, -40px) scale(1.25) rotateY(180deg) !important;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .card.discarded {
            transform: translate(-150%, 0) rotate(-45deg) !important;
            opacity: 0;
            transition: all 0.4s ease-in;
        }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .text-pop {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .side-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 9999px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 70px;
            height: 70px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Zoom ‡∏ö‡∏ô‡∏õ‡∏∏‡πà‡∏° */
            touch-action: manipulation; 
        }
        
        .side-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.1); }
        .side-btn:active { transform: scale(0.95); }
        .side-btn span { font-size: 24px; }
        .side-btn p { font-size: 10px; margin-top: 4px; font-weight: bold; }
        
        .side-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(0,0,0,0.2);
        }

        @media (min-width: 768px) {
            .deck-container { width: 300px; height: 450px; }
            .side-btn { width: 90px; height: 90px; }
            .side-btn span { font-size: 32px; }
            .side-btn p { font-size: 12px; }
        }
    </style>
</head>
<body>

    <div class="fixed top-6 w-full text-center z-40 pointer-events-none px-12">
        <h1 id="status-text" class="text-3xl md:text-5xl font-bold text-yellow-400 drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] text-pop leading-tight">
            ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß... ‡∏à‡∏±‡πà‡∏ß‡πÄ‡∏•‡∏¢!
        </h1>
    </div>

    <div class="fixed right-4 top-1/2 transform -translate-y-1/2 z-50 flex flex-col items-center">
        <button id="btn-shuffle" onclick="startShuffleSequence()" class="side-btn bg-yellow-500/20 hover:bg-yellow-500/40 border-yellow-400/50">
            <span class="material-icons-round text-yellow-300">shuffle</span>
            <p class="text-yellow-100">‡∏™‡∏±‡∏ö‡πÑ‡∏û‡πà</p>
        </button>
        <button onclick="instantRestart()" class="side-btn hover:bg-white/20 border-white/20">
            <span class="material-icons-round">replay</span>
            <p>‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</p>
        </button>
    </div>

    <div class="scene">
        <div class="deck-container" id="deck"></div>
    </div>

    <script>
        // --- ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏™‡∏£‡∏¥‡∏°: ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ Zoom ‡∏ó‡∏∏‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢ JS ---
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });
        document.addEventListener('dblclick', function(e) {
            e.preventDefault();
        }, { passive: false });

        // --- Game Logic ---
        const SoundFX = {
            ctx: null, buffer: null,
            init: function() {
                if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.buffer) {
                    const duration = 0.1; const sampleRate = this.ctx.sampleRate;
                    const bufferSize = sampleRate * duration;
                    const buffer = this.ctx.createBuffer(1, bufferSize, sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        data[i] = white * 0.1; 
                    }
                    this.buffer = buffer;
                }
            },
            playSnap: function() {
                if (!this.ctx || !this.buffer) return;
                const source = this.ctx.createBufferSource(); source.buffer = this.buffer;
                const filter = this.ctx.createBiquadFilter(); filter.type = "highpass"; filter.frequency.value = 800;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.04);
                source.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                source.start(); source.stop(this.ctx.currentTime + 0.1);
            },
            playSlide: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator(); osc.type = 'triangle';
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            },
            playTone: function(freq, type) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator(); osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.3);
            }
        };

        const initialCardData = [
            { text: "‡∏´‡∏°‡∏î‡πÅ‡∏Å‡πâ‡∏ß‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡∏ô‡∏µ‡πâ!", type: "hard" },
            { text: "‡∏Ñ‡∏ô‡∏ã‡πâ‡∏≤‡∏¢‡∏î‡∏∑‡πà‡∏° 1", type: "drink" },
            { text: "‡∏Ñ‡∏ô‡∏Ç‡∏ß‡∏≤‡∏î‡∏∑‡πà‡∏° 1", type: "drink" },
            { text: "‡∏à‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏´‡πâ‡∏≤‡∏°‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö", type: "action" },
            { text: "‡∏Ñ‡∏ô‡πÉ‡∏™‡πà‡πÅ‡∏ß‡πà‡∏ô‡∏î‡∏∑‡πà‡∏°", type: "drink" },
            { text: "‡πÉ‡∏Ñ‡∏£‡πÇ‡∏™‡∏î‡∏î‡∏∑‡πà‡∏°‡∏´‡∏°‡∏î‡πÅ‡∏Å‡πâ‡∏ß", type: "hard" },
            { text: "‡πÄ‡∏•‡πà‡∏≤‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡∏µ 1 ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á", type: "action" },
            { text: "‡πÄ‡∏ï‡πâ‡∏ô‡πÑ‡∏Å‡πà‡∏¢‡πà‡∏≤‡∏á 10 ‡∏ß‡∏¥", type: "action" },
            { text: "‡πÇ‡∏ó‡∏£‡∏´‡∏≤‡πÅ‡∏ü‡∏ô‡πÄ‡∏Å‡πà‡∏≤", type: "hard" },
            { text: "‡∏û‡∏π‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏±‡∏ö", type: "action" },
            { text: "‡πÄ‡∏õ‡πà‡∏≤‡∏¢‡∏¥‡πâ‡∏á‡∏â‡∏∏‡∏ö‡∏Ñ‡∏ô‡∏Ç‡πâ‡∏≤‡∏á‡πÜ", type: "drink" },
            { text: "‡∏Ñ‡∏ô‡πÄ‡∏™‡∏∑‡πâ‡∏≠‡∏î‡∏≥‡∏î‡∏∑‡πà‡∏°", type: "drink" },
            { text: "Free Turn!", type: "lucky" },
            { text: "‡∏û‡∏±‡∏Å‡∏î‡∏∑‡πà‡∏°‡∏ô‡πâ‡∏≥ 1 ‡πÅ‡∏Å‡πâ‡∏ß", type: "lucky" }
        ];

        const fullDeck = initialCardData.map((card, index) => ({ ...card, id: index }));
        let currentDeck = [...fullDeck];

        const reactionMap = {
            hard: ["‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏£‡∏¢‡πå!", "‡∏™‡∏π‡πà‡∏Ç‡∏¥‡∏ï...", "‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏¢‡∏¢‡∏¢‡∏¢‡∏¢", "‡πÑ‡∏°‡πà‡πÑ‡∏´‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏ù‡∏∑‡∏ô"],
            drink: ["‡∏Ñ‡∏≠‡πÅ‡∏´‡πâ‡∏á‡∏û‡∏≠‡∏î‡∏µ‡πÄ‡∏•‡∏¢", "‡∏´‡∏ß‡∏≤‡∏ô‡πÄ‡∏à‡∏µ‡πä‡∏¢‡∏ö‡∏ö‡∏ö", "‡∏ä‡∏ô‡πÅ‡∏Å‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö‡∏ú‡∏°", "‡πÄ‡∏ö‡∏≤‡πÜ ‡∏Å‡∏£‡∏∏‡∏ö‡∏Å‡∏£‡∏¥‡∏ö"],
            action: ["‡∏≠‡∏¢‡πà‡∏≤‡πÄ‡∏Ç‡∏¥‡∏ô‡∏î‡∏¥‡∏ß‡∏∞!", "‡πÄ‡∏≠‡∏≤‡πÉ‡∏´‡πâ‡∏™‡∏∏‡∏î!", "‡∏Å‡∏•‡πâ‡∏≤‡∏õ‡πà‡∏≤‡∏ß‡∏ß‡∏ß?", "‡∏Ç‡∏≠‡∏ï‡∏∂‡∏á‡πÜ ‡∏ô‡∏∞"],
            lucky: ["‡∏ó‡∏≥‡∏ö‡∏∏‡∏ç‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏∞‡πÑ‡∏£‡∏°‡∏≤?", "‡∏£‡∏≠‡∏î‡πÄ‡∏â‡∏¢‡∏¢‡∏¢‡∏¢", "‡πÅ‡∏ï‡πâ‡∏°‡∏ö‡∏∏‡∏ç‡∏™‡∏π‡∏á‡∏ô‡∏∞‡πÄ‡∏£‡∏≤", "‡∏á‡∏ß‡∏î‡∏ô‡∏µ‡πâ‡∏´‡∏ß‡∏¢‡∏≠‡∏≠‡∏Å‡πÅ‡∏ô‡πà"]
        };

        const waitingTexts = [
            "‡∏ï‡∏≤‡πÉ‡∏Ñ‡∏£‡πÄ‡∏≠‡πà‡∏¢?", "‡∏°‡∏∑‡∏≠‡∏™‡∏±‡πà‡∏ô‡∏ó‡∏≥‡πÑ‡∏°?", "‡πÉ‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡πÇ‡∏´‡∏î‡πÅ‡∏ô‡πà", "‡∏´‡∏¢‡∏¥‡∏ö‡∏™‡∏¥ ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏µ‡∏•‡∏≤", "‡∏à‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏≥‡πÑ‡∏° ‡∏à‡∏±‡πà‡∏ß‡∏™‡∏¥!"
        ];

        const deckContainer = document.getElementById('deck');
        const statusText = document.getElementById('status-text');
        const shuffleBtn = document.getElementById('btn-shuffle');
        let isShuffling = false;

        function updateStatus(mode, category = null) {
            let text = "";
            statusText.className = "text-3xl md:text-5xl font-bold drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] leading-tight"; 
            void statusText.offsetWidth;
            statusText.classList.add('text-pop');

            if (mode === 'waiting') {
                if (currentDeck.length === 0) {
                    text = "‡∏´‡∏°‡∏î‡∏Å‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà";
                    statusText.classList.add('text-gray-300');
                    shuffleBtn.disabled = true;
                } else {
                    text = waitingTexts[Math.floor(Math.random() * waitingTexts.length)];
                    statusText.classList.add('text-yellow-400');
                    shuffleBtn.disabled = false;
                }
            }
            else if (mode === 'reaction' && category) {
                const options = reactionMap[category] || reactionMap['drink'];
                text = options[Math.floor(Math.random() * options.length)];
                if (category === 'hard') statusText.classList.add('text-red-600'); 
                else if (category === 'lucky') statusText.classList.add('text-green-400'); 
                else statusText.classList.add('text-red-400'); 
            }
            statusText.innerText = text;
        }

        function instantRestart() {
            if (isShuffling) return;
            SoundFX.init();
            SoundFX.playSlide();
            currentDeck = [...fullDeck];
            deployRealDeck();
            updateStatus('waiting');
        }

        function startShuffleSequence() {
            if (isShuffling) return;
            if (currentDeck.length === 0) return;

            isShuffling = true;
            SoundFX.init();
            deckContainer.innerHTML = ''; 
            updateStatus('waiting'); 

            const STUNT_COUNT = Math.min(8, currentDeck.length);
            const stuntCards = [];
            
            for(let i=0; i<STUNT_COUNT; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.style.transform = `translate(0, 0) rotate(0deg)`;
                card.innerHTML = `<div class="card-face card-back"></div>`; 
                deckContainer.appendChild(card);
                stuntCards.push(card);
            }

            stuntCards.forEach((card, i) => {
                setTimeout(() => {
                    SoundFX.playSnap();
                    card.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
                    const centerIndex = STUNT_COUNT / 2;
                    const spreadX = (i - centerIndex) * 25; 
                    const jumpY = -110; 
                    const rotate = (i - centerIndex) * 5; 
                    card.style.transform = `translate(${spreadX}px, ${jumpY}px) rotate(${rotate}deg)`;
                }, i * 30);
            });

            const fallStartTime = (STUNT_COUNT * 30) + 500;
            const fallStagger = 50;
            
            stuntCards.forEach((card, i) => {
                setTimeout(() => {
                    card.style.transition = 'transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    const randomRot = (Math.random() * 2) - 1;
                    card.style.transform = `translate(0px, 0px) rotate(${randomRot}deg)`;
                }, fallStartTime + (i * fallStagger));
            });

            const finishTime = fallStartTime + (STUNT_COUNT * fallStagger) + 800; 
            
            setTimeout(() => {
                deployRealDeck();
                isShuffling = false;
            }, finishTime);
        }

        function deployRealDeck() {
            deckContainer.innerHTML = '';
            const shuffled = [...currentDeck].sort(() => Math.random() - 0.5);
            shuffled.forEach((item, index) => {
                const card = document.createElement('div');
                card.classList.add('card');
                card.style.zIndex = index + 1;
                card.dataset.id = item.id;
                card.dataset.type = item.type;
                const randomRot = (Math.random() * 2) - 1; 
                card.style.transform = `translate(0px, 0px) rotate(${randomRot}deg)`;
                card.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front">
                        <div class="flex flex-col items-center px-4">
                            <span class="text-3xl mb-4">üçª</span>
                            <span>${item.text}</span>
                        </div>
                    </div>
                `;
                card.onclick = () => handleCardClick(card);
                deckContainer.appendChild(card);
            });
        }

        function handleCardClick(card) {
            if (isShuffling) return; 
            if (card.classList.contains('discarded')) return;
            SoundFX.init();

            if (card.classList.contains('active')) {
                SoundFX.playSlide(); 
                card.classList.remove('active');
                card.classList.add('discarded');
                const cardId = parseInt(card.dataset.id);
                currentDeck = currentDeck.filter(c => c.id !== cardId);
                setTimeout(() => { updateStatus('waiting'); }, 300);
                setTimeout(() => card.remove(), 600);
            } else {
                const nextCard = card.nextElementSibling;
                if (!nextCard || nextCard.classList.contains('discarded')) {
                    card.classList.add('active');
                    const cardType = card.dataset.type;
                    updateStatus('reaction', cardType);
                    if (cardType === 'hard') SoundFX.playTone(100, 'sawtooth');
                    else if (cardType === 'lucky') SoundFX.playTone(600, 'sine');
                    else SoundFX.playTone(400, 'sine');
                }
            }
        }

        setTimeout(() => {
            deployRealDeck();
            updateStatus('waiting');
        }, 100);

    </script>
</body>
</html>